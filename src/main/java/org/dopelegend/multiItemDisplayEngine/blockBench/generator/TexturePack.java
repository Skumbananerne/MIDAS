package org.dopelegend.multiItemDisplayEngine.blockBench.generator;

import com.google.gson.*;
import it.unimi.dsi.fastutil.Pair;
import org.bukkit.Bukkit;
import org.dopelegend.multiItemDisplayEngine.MultiItemDisplayEngine;
import org.dopelegend.multiItemDisplayEngine.files.utils.FileGetter;
import org.dopelegend.multiItemDisplayEngine.files.utils.Zip;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.zip.ZipEntry;

public class TexturePack {
    private static File[] allModels = null;
    /**
     *
     * Gets all model files in the model folder
     *
     * @return Array of all model files in the model folder and null if no files were found.
     */
    public static File[] getAllFiles() {
        if(allModels != null) return allModels;
        File dir = FileGetter.getModelFolder();
        FilenameFilter filter = (file, name) -> name.toLowerCase().endsWith("bbmodel");
        allModels = dir.listFiles(filter);
        return dir.listFiles(filter);
    }


    /**
     *
     * Generates a texturepack in the temp folder, from all the .bbmodel files in the models folder.
     *
     * @return Whether the generation was successful or not
     */
    public static boolean generateTexturePack() {


        File[] files = getAllFiles();

        if (files==null) return true;

        // Change this to change the texture pack name
        String texturePackName = "TexturePack";
        File workingDir = new File(FileGetter.getTempFolder(), texturePackName);
        deleteTexturepackFolder(workingDir);

        workingDir.mkdirs();

        try{
            // Generate file structure
            generatePackMeta(workingDir);
            generateItemsFolder(workingDir);
            generateTextures(workingDir);
            generateModels(workingDir);

        } catch (Exception e) {
            deleteTexturepackFolder(workingDir);
            MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
            MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            return false;
        }

        //DEV
        try {
            File tempZip = FileGetter.getTempFolder()
                    .toPath()
                    .resolve("pack.zip")
                    .toFile();

            File finalZip = FileGetter.getTexturePackFolder()
                    .toPath()
                    .resolve("pack.zip")
                    .toFile();

            Zip.zip(workingDir, tempZip);

            Files.move(
                    tempZip.toPath(),
                    finalZip.toPath(),
                    StandardCopyOption.REPLACE_EXISTING
            );
        } catch (Exception e){
            MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
            MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            return  false;
        }

        return true;
    }


    /**
     *
     * generates the pack.mcmeta file in the root texturepack file (workingDir/pack.mcmeta)
     *
     * @param workingDir The root texturepack file
     */
    private static void generatePackMeta(File workingDir){
        // Generate pack.mcmeta
        try {
            File packMeta = new File(workingDir, "pack.mcmeta");
            Files.writeString(packMeta.toPath(),
                    """
        {
          "pack": {
            "pack_format": 64,
            "description": "Autogenerated by MultiItemDisplayEngine using Blockbench models"
          }
        }
        """);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }


    /**
     *
     * Generates the model overrider file in the texture pack (workingDir/assets/midas/items/diamond.json), the workingDir is the root texturepack file.
     *
     * @param workingDir The root texturepack file
     */
    private static void generateItemsFolder(File workingDir){
        // Generate pack.mcmeta
        try {
            JsonArray cases = new JsonArray();
            JsonObject[] allBones = getAllBones();

            for (JsonObject bone : allBones) {
                //Todo skip if no elements in bone
                String boneUuid = bone.get("uuid").getAsString();

                JsonObject boneEntry = new JsonObject();
                boneEntry.addProperty("when", boneUuid);

                JsonObject model = new JsonObject();
                model.addProperty("type", "model");
                model.addProperty("model", "item/" + boneUuid);
                boneEntry.add("model", model);

                cases.add(boneEntry);
            }

            // Fallback object
            JsonObject fallback = new JsonObject();
            fallback.addProperty("type", "model");
            fallback.addProperty("model", "block/diamond_block");

            // Model object
            JsonObject model = new JsonObject();
            model.addProperty("type", "select");
            model.addProperty("property", "custom_model_data");
            model.add("cases", cases);
            model.add("fallback", fallback);

            // Wrap it in root
            JsonObject root = new JsonObject();
            root.add("model", model);

            // Pretty-print
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String json = gson.toJson(root);

            // Write to file
            File file = new File(workingDir, "assets/midas/items/diamond_block.json");
            file.getParentFile().mkdirs();
            Files.writeString(file.toPath(), json);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    /**
     *
     * Generates the models folder (workingDir/assets/midas/models) and its subdirectories (models/item/uuid.json).
     * The main point of this function is creating all the modelname.json files from the .bbmodel files in the plugin's models folder
     *
     * @param workingDir The root texturepack file
     */
    private static void generateModels(File workingDir){
        //Get all bones
        List<Pair<JsonObject, JsonObject>> allBones = getAllBonesWithRootJson();
        File itemModelsFolder = new File(workingDir, "assets/midas/models/item");
        if (!itemModelsFolder.exists()) {
            itemModelsFolder.mkdirs();
        }
        //Loop through all bones (one bone = one json file)
        for (Pair<JsonObject, JsonObject> boneAndJsonRootPair : allBones) {
            List<JsonObject> bbFileElements = getAllElementsFromBone(boneAndJsonRootPair.right(), boneAndJsonRootPair.left());
            if(bbFileElements.isEmpty()){
                continue;
            }

            //Get uuid
            String uuid = boneAndJsonRootPair.left().get("uuid").getAsString();

            //Make .json
            JsonObject rootJson = new JsonObject();
            rootJson.addProperty("format_version", "1.21.8");
            rootJson.addProperty("credit", "Autogenerated by MultiItemDisplayEngine using Blockbench models");
            //Make texture size array
            JsonArray textureSize = new JsonArray();
            //Get texture resolution from .bbmodel file
            JsonObject bbModelResolutionSize = boneAndJsonRootPair.right().get("resolution").getAsJsonObject();
            textureSize.add(bbModelResolutionSize.get("width").getAsInt());
            textureSize.add(bbModelResolutionSize.get("height").getAsInt());

            //Add texture size to .json file
            rootJson.add("texture_size", textureSize);

            // textures
            JsonObject texturesObject = new JsonObject();
            texturesObject.addProperty("-1", "block/diamond_block");
            // Add particle field (Minecraft will throw errors in the client log if this isn't present)
            texturesObject.addProperty("particle", "block/diamond_block");

            JsonObject[] textures = getAllTexture(boneAndJsonRootPair.right());

            // known ids so we don't duplicate entries
            List<Integer> knownIds = new ArrayList<>();
            String[] directions = {
                    "north",
                    "east",
                    "south",
                    "west",
                    "up",
                    "down",
            };
            // loop all elements
            for (JsonObject element : bbFileElements) {
                JsonObject faces = element.getAsJsonObject("faces");

                // loop all faces as they can have different textures
                for (int i = 0; i < faces.size(); i++) {
                    JsonObject face = faces.get(directions[i]).getAsJsonObject();

                    // if they don't have a texture fallback
                    if(!face.has("texture")) continue;

                    // get texture id
                    int id = face.get("texture").getAsInt();
                    if(knownIds.contains(id)) continue;

                    // loop all textures
                    for (JsonObject texture : textures){
                        if(texture.get("id").getAsInt() == id){
                            // add texture to texturesObject and known ids
                            texturesObject.addProperty(String.valueOf(id), "item/" + texture.get("uuid").getAsString());
                            knownIds.add(id);
                        }
                    }
                }
            }
            rootJson.add("textures", texturesObject);

            // Make elements Array
            JsonArray elements = new JsonArray();

            double fromX = bbFileElements.getFirst().get("from").getAsJsonArray().get(0).getAsDouble();
            double fromY = bbFileElements.getFirst().get("from").getAsJsonArray().get(1).getAsDouble();
            double fromZ = bbFileElements.getFirst().get("from").getAsJsonArray().get(2).getAsDouble();
            //Loop through all elements in bone
            for (JsonObject bbElement : bbFileElements) {

                //Create element
               JsonObject element = new JsonObject();

                //Add name property
                element.addProperty("name", bbElement.get("uuid").getAsString());
                //----------------------------------
                //              TEMP
                //----------------------------------
                JsonArray toArray = new JsonArray();
                JsonArray fromArray = new JsonArray();

                toArray.add(bbElement.get("to").getAsJsonArray().get(0).getAsDouble()-fromX);
                toArray.add(bbElement.get("to").getAsJsonArray().get(1).getAsDouble()-fromY);
                toArray.add(bbElement.get("to").getAsJsonArray().get(2).getAsDouble()-fromZ);

                fromArray.add(bbElement.get("from").getAsJsonArray().get(0).getAsDouble()-fromX);
                fromArray.add(bbElement.get("from").getAsJsonArray().get(1).getAsDouble()-fromY);
                fromArray.add(bbElement.get("from").getAsJsonArray().get(2).getAsDouble()-fromZ);

                //----------------------------------

                element.add("from", fromArray);
                element.add("to", toArray);

                // Rotation
                JsonObject rotation = new JsonObject();
                JsonArray origin = bbElement.get("origin").getAsJsonArray();
                int rotAngle = 0;
                char rotAxis = 'x';
                if(bbElement.has("rotation")){
                    JsonArray rotationArray = bbElement.get("rotation").getAsJsonArray();


                    for (int i = 0; i < rotationArray.size(); i++) {
                        int rot = rotationArray.get(i).getAsInt();
                        if(rot > 0){
                            rotAngle = rot;
                            if(i == 1) rotAxis = 'y';
                            if(i == 2) rotAxis = 'z';
                        }
                    }
                }

                rotation.addProperty("angle", rotAngle);
                rotation.addProperty("axis", rotAxis);
                rotation.add("origin", origin);

                element.add("rotation", rotation);

                //Faces
                JsonObject faces = new JsonObject();

                for(String direction : directions){
                    JsonObject face = new JsonObject();
                    int resSize = 16;
                    JsonArray uvArray = bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .get("uv").getAsJsonArray();

                    for (int i = 0; i < uvArray.size(); i++) {
                        JsonElement uv = new JsonPrimitive(uvArray.get(i).getAsFloat()/(bbModelResolutionSize.get("width").getAsFloat() / resSize));
                        uvArray.set(i, uv);
                    }
                    face.add("uv", uvArray);

                    boolean hasTexture = bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .has("texture");
                    face.addProperty("texture", "#" + (hasTexture ? bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .get("texture").getAsString() : -1));

                    faces.add(direction, face);
                }
                element.add("faces", faces);
                elements.add(element);
            }

            rootJson.add("elements", elements);

            try {
                Gson gson = new GsonBuilder().setPrettyPrinting().create();
                String json = gson.toJson(rootJson);

                File file = new File(workingDir, "assets/midas/models/item/" + uuid + ".json");
                file.getParentFile().mkdirs();
                Files.writeString(file.toPath(), json);
            } catch (IOException e) {
                MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
                MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            }
        }
    }


    /**
     *
     * Generates the textures folder (workingDir/assets/midas/textures) and its subdirectories (textures/item/uuid.).
     * The main point of this function is creating all the texture files from the .bbmodel files in the plugin's models folder
     *
     * @param workingDir The root texturepack file
     */
    private static void generateTextures(File workingDir){
        //generate path
        File textureFolder = new File(workingDir, "assets/midas/textures/item");
        textureFolder.mkdirs();

        File[] allModels = getAllFiles();

        for (File modelFile : allModels) {
            JsonObject modelData;
            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            JsonArray textureArray = modelData.get("textures").getAsJsonArray();


            for (int i = 0; i < textureArray.size(); i++) {
                JsonObject texture = textureArray.get(i).getAsJsonObject();

                File file = new File(
                        workingDir,
                        "assets/midas/textures/item/" + texture.get("uuid").getAsString() + ".png"
                );

                String source = texture.get("source").getAsString();
                String base64Data = source.replaceFirst("^data:image/[^;]+;base64,", "");

                byte[] imageBytes = Base64.getDecoder().decode(base64Data);

                try (OutputStream out = new FileOutputStream(file)) {
                    out.write(imageBytes);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }


    /**
     *
     * Gets all textures from a model file root object
     *
     * @param modelData The root JsonObject in model file
     *
     * @return A list of JsonObject or an empty list if none were found
     */
    private static JsonObject[] getAllTexture(JsonObject modelData){
        JsonArray textureArray = modelData.get("textures").getAsJsonArray();
        JsonObject[] textures = new JsonObject[textureArray.size()];
        for (int i = 0; i < textures.length; i++) {
            textures[i] = textureArray.get(i).getAsJsonObject();
        }
        return textures;
    }


    /**
     *
     * Gets all immediate children elements from a bone
     *
     * @param modelData The root JsonObject in model file
     * @param bone The bone that is going to be searched
     *
     * @return A list of JsonObject or an empty list if none were found
     */
    private static List<JsonObject> getAllElementsFromBone(JsonObject modelData, JsonObject bone){
        // get all elements in file
        JsonArray elementsArray = modelData.get("elements").getAsJsonArray();
        JsonObject[] elements = new JsonObject[elementsArray.size()];
        for (int i = 0; i < elements.length; i++) {
            elements[i] = elementsArray.get(i).getAsJsonObject();
        }

        List<JsonObject> outputElements = new ArrayList<>();
        JsonArray childrenArray = bone.get("children").getAsJsonArray();

        // loop each child the bone has
        for (int i = 0; i < childrenArray.size(); i++) {
            // if entry is uuid(string)
            if (!(childrenArray.get(i) instanceof JsonObject)) {
                String childId = childrenArray.get(i).getAsString();
                // loop all elements in file
                for(JsonObject obj : elements){
                    // add if same uuid
                    if(Objects.equals(obj.get("uuid").getAsString(), childId)) outputElements.add(obj);
                }
            }
        }
        return outputElements;
    }


    /**
     *
     * Gets an array with all the bones in all .bbmodel files.
     *
     * @return The array with all the bones.
     */
    private static JsonObject[] getAllBones(){
        File[] allModels = getAllFiles();
        List<JsonObject> bones = new ArrayList<>();
        for (File modelFile : allModels) {
            JsonObject modelData;
            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            JsonArray boneArray = modelData.get("outliner").getAsJsonArray();
            JsonObject rootBone = boneArray.get(0).getAsJsonObject();
            bones.add(rootBone);
            bones.addAll(Arrays.stream(getChildBones(rootBone)).toList());
        }
        return bones.toArray(new JsonObject[0]);
    }

    /**
     *
     * Gets an list of pairs with all the bones in all .bbmodel files and all the rootJsonObjects belonging to them.
     *
     * @return The List of pairs with all the bones and root files, pair.left is the bone, and pair.right is the rootJsonObject.
     */
    private static List<Pair<JsonObject, JsonObject>> getAllBonesWithRootJson(){
        File[] allModels = getAllFiles();
        List<Pair<JsonObject, JsonObject>> bonesAndRootJson = new ArrayList<>();
        for (File modelFile : allModels) {
            JsonObject modelData;
            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            JsonArray boneArray = modelData.get("outliner").getAsJsonArray();
            JsonObject rootBone = boneArray.get(0).getAsJsonObject();
            bonesAndRootJson.add(Pair.of(rootBone, modelData));
            bonesAndRootJson.addAll(getChildBonesWithRootJson(rootBone, modelData));
        }
        return bonesAndRootJson;
    }

    /**
     *
     * Gets all the bones under the root bone in the bone hierarchy.
     *
     * @param bone The root bone
     * @return All the bones under the bone.
     */
    private static JsonObject[] getChildBones(JsonObject bone) {
        JsonArray childrenArray = bone.get("children").getAsJsonArray();

        List<JsonObject> bones = new ArrayList<>();
        for (int i = 0; i < childrenArray.size(); i++) {
            if (childrenArray.get(i) instanceof JsonObject) {
                JsonObject childBone = childrenArray.get(i).getAsJsonObject();
                bones.addAll(Arrays.asList(getChildBones(childBone)));
                bones.add(childBone);
            }
        }
        return bones.toArray(new JsonObject[0]);
    }

    /**
     *
     * Gets all the bones under the root bone in the bone hierarchy, and adds the rootJsonObject to all of them.
     *
     * @param bone The root bone
     * @param rootJson The rootJsonObject
     * @return All the bones under the bone and the rootJson in a list of pairs where pair.left is the bone, and pair.right is the rootJson.
     */
    private static List<Pair<JsonObject, JsonObject>> getChildBonesWithRootJson(JsonObject bone, JsonObject rootJson) {
        JsonArray childrenArray = bone.get("children").getAsJsonArray();

        List<Pair<JsonObject, JsonObject>> bonesAndRootJson = new ArrayList<>();

        for (int i = 0; i < childrenArray.size(); i++) {
            if (childrenArray.get(i) instanceof JsonObject) {
                JsonObject childBone = childrenArray.get(i).getAsJsonObject();
                bonesAndRootJson.add(Pair.of(childBone, rootJson));
                bonesAndRootJson.addAll(getChildBonesWithRootJson(childBone, rootJson));
            }
        }
        return bonesAndRootJson;
    }


    private static boolean deleteTexturepackFolder(File dir){
        try {
            if (dir.isDirectory()) {
                File[] files = dir.listFiles();
                if (files != null) {
                    for (File f : files) {
                        if (!deleteTexturepackFolder(f)) {
                            return false;
                        }
                    }
                }
            }
            return dir.delete();
        } catch (Exception e){
            if (dir != null && dir.exists()) {
                MultiItemDisplayEngine.plugin.getLogger().severe("Could not delete texturepack folder\n" + e.getMessage());
            }
            return false;
        }

    }
}

