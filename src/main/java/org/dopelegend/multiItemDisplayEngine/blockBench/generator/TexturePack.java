package org.dopelegend.multiItemDisplayEngine.blockBench.generator;

import com.google.gson.*;
import it.unimi.dsi.fastutil.Pair;
import org.bukkit.Bukkit;
import org.dopelegend.multiItemDisplayEngine.MultiItemDisplayEngine;
import org.dopelegend.multiItemDisplayEngine.files.utils.FileGetter;
import org.dopelegend.multiItemDisplayEngine.files.utils.FileUtil;
import org.dopelegend.multiItemDisplayEngine.files.utils.Zip;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.zip.ZipEntry;

public class TexturePack {
    private static File[] allModels = null;
    /**
     *
     * Gets all model files in the model folder
     *
     * @return Array of all model files in the model folder and null if no files were found.
     */
    public static File[] getAllFiles() {
        if(allModels != null) return allModels;
        File dir = FileGetter.getModelFolder();
        FilenameFilter filter = (file, name) -> name.toLowerCase().endsWith("bbmodel");
        allModels = dir.listFiles(filter);
        return dir.listFiles(filter);
    }


    /**
     *
     * Generates a texturepack in the temp folder, from all the .bbmodel files in the models folder.
     *
     * @return Whether the generation was successful or not
     */
    public static boolean generateTexturePack() {
        File[] files = getAllFiles();

        if (files==null) return true;

        // Change this to change the texture pack name
        String texturePackName = "pack";
        File workingDir = new File(FileGetter.getTempFolder(), texturePackName);
        FileUtil.deleteDirectory(workingDir);

        workingDir.mkdirs();

        try{
            // Generate file structure
            generatePackMeta(workingDir);
            generateItemsFolder(workingDir);
            generateTextures(workingDir);
            generateModels(workingDir);

        } catch (Exception e) {
            FileUtil.deleteDirectory(workingDir);
            MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
            MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            return false;
        }

        //DEV
        try {
            File tempZip = FileGetter.getTempFolder()
                    .toPath()
                    .resolve("pack.zip")
                    .toFile();

            File finalZip = FileGetter.getTexturePackFolder()
                    .toPath()
                    .resolve("pack.zip")
                    .toFile();

            Zip.zip(workingDir, tempZip);

            Files.move(
                    tempZip.toPath(),
                    finalZip.toPath(),
                    StandardCopyOption.REPLACE_EXISTING
            );
        } catch (Exception e){
            MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
            MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            return false;
        } finally {
            //FileUtil.deleteDirectory(workingDir);
        }

        return true;
    }


    /**
     *
     * generates the pack.mcmeta file in the root texturepack file (workingDir/pack.mcmeta)
     *
     * @param workingDir The root texturepack file
     */
    private static void generatePackMeta(File workingDir){
        // Generate pack.mcmeta
        try {
            File packMeta = new File(workingDir, "pack.mcmeta");
            Files.writeString(packMeta.toPath(),
                    """
        {
          "pack": {
            "pack_format": 64,
            "description": "Autogenerated by MultiItemDisplayEngine using Blockbench models"
          }
        }
        """);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }


    /**
     *
     * Generates the model overrider file in the texture pack (workingDir/assets/midas/items/diamond.json), the workingDir is the root texturepack file.
     *
     * @param workingDir The root texturepack file
     */
    private static void generateItemsFolder(File workingDir){
        // Generate the items folder
        try {
            List<Pair<JsonObject, JsonObject>> allBones = getAllBonesWithRootJson();
            for (Pair<JsonObject, JsonObject> boneAndRoot : allBones) {
                JsonObject rootObject = boneAndRoot.right();
                JsonArray outliner = rootObject.getAsJsonArray("outliner");
                String modelName = rootObject.get("name").getAsString();

                JsonObject outlinerBone = getOutlinerBoneFromUUID(boneAndRoot.left().get("uuid").getAsString(), outliner);

                for (JsonElement child : outlinerBone.get("children").getAsJsonArray()) {
                    if (child instanceof JsonPrimitive elementID) {
                        File itemsFile = new File(workingDir.toPath().resolve("assets/midas/items/" + modelName).toFile(), elementID.getAsString() + ".json");

                        File parentFile = itemsFile.getParentFile();
                        if(!parentFile.exists() && !parentFile.mkdirs()){
                            MultiItemDisplayEngine.plugin.getLogger().warning("Could not create items folder " + itemsFile.getAbsolutePath());
                            return;
                        }

                        JsonObject modelObject = new JsonObject();
                        modelObject.addProperty("type", "minecraft:model");
                        modelObject.addProperty("model", "midas:item/" + modelName + "/" + elementID.getAsString());

                        JsonObject rootJsonObject = new JsonObject();

                        rootJsonObject.add("model", modelObject);

                        try {
                            Gson gson = new GsonBuilder().setPrettyPrinting().create();
                            String json = gson.toJson(rootJsonObject);

                            Files.writeString(itemsFile.toPath(), json);
                        }
                        catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }

        }
        catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    /**
     *
     * Generates the models folder (workingDir/assets/midas/models) and its subdirectories (models/item/uuid.json).
     * The main point of this function is creating all the modelname.json files from the .bbmodel files in the plugin's models folder
     *
     * @param workingDir The root texturepack file
     */
    private static void generateModels(File workingDir){
        //Get all bones
        List<Pair<JsonObject, JsonObject>> allBones = getAllBonesWithRootJson();
        File itemModelsFolder = new File(workingDir, "assets/midas/models/item");
        if (!itemModelsFolder.exists()) {
            itemModelsFolder.mkdirs();
        }
        //Loop through all bones (one bone = one json file)
        for (Pair<JsonObject, JsonObject> boneAndJsonRootPair : allBones) {
            List<JsonObject> bbFileElements = getAllElementsFromBone(boneAndJsonRootPair.right(), boneAndJsonRootPair.left());
            if(bbFileElements.isEmpty()){
                continue;
            }

            //Get uuid
            String uuid = boneAndJsonRootPair.left().get("uuid").getAsString();

            //Make .json
            JsonObject rootJson = new JsonObject();
            rootJson.addProperty("format_version", "1.21.8");
            rootJson.addProperty("credit", "Autogenerated by MultiItemDisplayEngine using Blockbench models");
            //Make texture size array
            JsonArray textureSize = new JsonArray();
            //Get texture resolution from .bbmodel file
            JsonObject bbModelResolutionSize = boneAndJsonRootPair.right().get("resolution").getAsJsonObject();
            textureSize.add(bbModelResolutionSize.get("width").getAsInt());
            textureSize.add(bbModelResolutionSize.get("height").getAsInt());

            //Add texture size to .json file
            rootJson.add("texture_size", textureSize);

            // textures
            JsonObject texturesObject = new JsonObject();
            texturesObject.addProperty("-1", "block/diamond_block");
            // Add particle field (Minecraft will throw errors in the client log if this isn't present)
            texturesObject.addProperty("particle", "block/diamond_block");

            JsonObject[] textures = getAllTexture(boneAndJsonRootPair.right());

            // known ids so we don't duplicate entries
            List<Integer> knownIds = new ArrayList<>();
            String[] directions = {
                    "north",
                    "east",
                    "south",
                    "west",
                    "up",
                    "down",
            };
            // loop all elements
            for (JsonObject element : bbFileElements) {
                JsonObject faces = element.getAsJsonObject("faces");

                // loop all faces as they can have different textures
                for (int i = 0; i < faces.size(); i++) {
                    JsonObject face = faces.get(directions[i]).getAsJsonObject();

                    // if they don't have a texture fallback
                    if(!face.has("texture")) continue;

                    // get texture id
                    int id = face.get("texture").getAsInt();
                    if(knownIds.contains(id)) continue;

                    // loop all textures
                    for (JsonObject texture : textures){
                        if(texture.get("id").getAsInt() == id){
                            // add texture to texturesObject and known ids
                            texturesObject.addProperty(String.valueOf(id), "item/" + texture.get("uuid").getAsString());
                            knownIds.add(id);
                        }
                    }
                }
            }
            rootJson.add("textures", texturesObject);

            // Make elements Array
            JsonArray elements = new JsonArray();

            double fromX = bbFileElements.getFirst().get("from").getAsJsonArray().get(0).getAsDouble();
            double fromY = bbFileElements.getFirst().get("from").getAsJsonArray().get(1).getAsDouble();
            double fromZ = bbFileElements.getFirst().get("from").getAsJsonArray().get(2).getAsDouble();
            //Loop through all elements in bone
            for (JsonObject bbElement : bbFileElements) {

                //Create element
               JsonObject element = new JsonObject();

                //Add name property
                element.addProperty("name", bbElement.get("uuid").getAsString());
                //----------------------------------
                //              TEMP
                //----------------------------------
                JsonArray toArray = new JsonArray();
                JsonArray fromArray = new JsonArray();

                toArray.add(bbElement.get("to").getAsJsonArray().get(0).getAsDouble()-fromX);
                toArray.add(bbElement.get("to").getAsJsonArray().get(1).getAsDouble()-fromY);
                toArray.add(bbElement.get("to").getAsJsonArray().get(2).getAsDouble()-fromZ);

                fromArray.add(bbElement.get("from").getAsJsonArray().get(0).getAsDouble()-fromX);
                fromArray.add(bbElement.get("from").getAsJsonArray().get(1).getAsDouble()-fromY);
                fromArray.add(bbElement.get("from").getAsJsonArray().get(2).getAsDouble()-fromZ);

                //----------------------------------

                element.add("from", fromArray);
                element.add("to", toArray);

                // Rotation
                JsonObject rotation = new JsonObject();
                JsonArray origin = bbElement.get("origin").getAsJsonArray();
                int rotAngle = 0;
                char rotAxis = 'x';
                if(bbElement.has("rotation")){
                    JsonArray rotationArray = bbElement.get("rotation").getAsJsonArray();


                    for (int i = 0; i < rotationArray.size(); i++) {
                        int rot = rotationArray.get(i).getAsInt();
                        if(rot > 0){
                            rotAngle = rot;
                            if(i == 1) rotAxis = 'y';
                            if(i == 2) rotAxis = 'z';
                        }
                    }
                }

                rotation.addProperty("angle", rotAngle);
                rotation.addProperty("axis", rotAxis);
                rotation.add("origin", origin);

                element.add("rotation", rotation);

                //Faces
                JsonObject faces = new JsonObject();

                for(String direction : directions){
                    JsonObject face = new JsonObject();
                    int resSize = 16;
                    JsonArray uvArray = bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .get("uv").getAsJsonArray();

                    for (int i = 0; i < uvArray.size(); i++) {
                        JsonElement uv = new JsonPrimitive(uvArray.get(i).getAsFloat()/(bbModelResolutionSize.get("width").getAsFloat() / resSize));
                        uvArray.set(i, uv);
                    }
                    face.add("uv", uvArray);

                    boolean hasTexture = bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .has("texture");
                    face.addProperty("texture", "#" + (hasTexture ? bbElement
                            .get("faces").getAsJsonObject()
                            .get(direction).getAsJsonObject()
                            .get("texture").getAsString() : -1));

                    faces.add(direction, face);
                }
                element.add("faces", faces);
                elements.add(element);
            }

            rootJson.add("elements", elements);

            try {
                Gson gson = new GsonBuilder().setPrettyPrinting().create();
                String json = gson.toJson(rootJson);

                File file = new File(workingDir, "assets/midas/models/item/" + boneAndJsonRootPair.right().get("name").getAsString() + "/" + uuid + ".json");
                file.getParentFile().mkdirs();
                Files.writeString(file.toPath(), json);
            } catch (IOException e) {
                MultiItemDisplayEngine.plugin.getLogger().warning(e.getMessage());
                MultiItemDisplayEngine.plugin.getLogger().warning(Arrays.toString(e.getStackTrace()));
            }
        }
    }


    /**
     *
     * Generates the textures folder (workingDir/assets/midas/textures) and its subdirectories (textures/item/uuid.).
     * The main point of this function is creating all the texture files from the .bbmodel files in the plugin's models folder
     *
     * @param workingDir The root texturepack file
     */
    private static void generateTextures(File workingDir){
        //generate path
        File textureFolder = new File(workingDir, "assets/midas/textures/item");
        textureFolder.mkdirs();

        File[] allModels = getAllFiles();

        for (File modelFile : allModels) {
            JsonObject modelData;
            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            JsonArray textureArray = modelData.get("textures").getAsJsonArray();


            for (int i = 0; i < textureArray.size(); i++) {
                JsonObject texture = textureArray.get(i).getAsJsonObject();

                File file = new File(
                        workingDir,
                        "assets/midas/textures/item/" + modelData.get("name").getAsString() + "/" + texture.get("uuid").getAsString() + ".png"
                );
                file.getParentFile().mkdirs();

                String source = texture.get("source").getAsString();
                String base64Data = source.replaceFirst("^data:image/[^;]+;base64,", "");

                byte[] imageBytes = Base64.getDecoder().decode(base64Data);

                try (OutputStream out = new FileOutputStream(file)) {
                    out.write(imageBytes);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }


    /**
     *
     * Gets all textures from a model file root object
     *
     * @param modelData The root JsonObject in model file
     *
     * @return A list of JsonObject or an empty list if none were found
     */
    private static JsonObject[] getAllTexture(JsonObject modelData){
        JsonArray textureArray = modelData.get("textures").getAsJsonArray();
        JsonObject[] textures = new JsonObject[textureArray.size()];
        for (int i = 0; i < textures.length; i++) {
            textures[i] = textureArray.get(i).getAsJsonObject();
        }
        return textures;
    }


    /**
     *
     * Gets all immediate children elements from a bone
     *
     * @param modelData The root JsonObject in model file
     * @param bone The bone that is going to be searched
     *
     * @return A list of JsonObject or an empty list if none were found
     */
    private static List<JsonObject> getAllElementsFromBone(JsonObject modelData, JsonObject bone){
        List<JsonObject> children = new ArrayList<>();
        String uuid = bone.get("uuid").getAsString();
        if (uuid == null){
            MultiItemDisplayEngine.plugin.getLogger().warning("Missing uuid for bone: " + bone);
            return children;
        }

        JsonArray elements = modelData.get("elements").getAsJsonArray();
        if (elements == null){
            MultiItemDisplayEngine.plugin.getLogger().warning("No elements in file with bone: " + bone);
            return children;
        }

        JsonArray outlinerArray = modelData.get("outliner").getAsJsonArray();

        JsonObject outlinerBone = getOutlinerBoneFromUUID(uuid, outlinerArray);
        for (JsonElement child : outlinerBone.get("children").getAsJsonArray()) {
            if (!(child instanceof JsonPrimitive elementID)) continue;
            for(JsonElement element : elements){
                if (!(element instanceof JsonObject elementObject)) continue;

                if (elementObject.get("uuid").getAsString().equals(elementID.getAsString())) {
                    children.add(elementObject);
                }
            }
        }

        return children;
    }


    /**
     *
     * Gets an array with all the bones in all .bbmodel files.
     *
     * @return The array with all the bones.
     */
    private static JsonObject[] getAllBones(){
        //TODO make this use the groups array
        File[] allModels = getAllFiles();
        List<JsonObject> bones = new ArrayList<>();

        for (File modelFile : allModels) {
            JsonObject modelData;

            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            // Get rootbone in outliner
            JsonArray outlinerArray = modelData.get("outliner").getAsJsonArray();
            JsonObject rootOutlinerBone = outlinerArray.get(0).getAsJsonObject();

            // Get group
            JsonArray groupArray = modelData.get("groups").getAsJsonArray();


            // Get root bone
            JsonObject rootBone = getBoneFromUUID(rootOutlinerBone.get("uuid").getAsString(), groupArray);

            if (rootBone.isEmpty()){
                return new JsonObject[0];
            }

            bones.add(rootBone);
            bones.addAll(Arrays.stream(getChildBones(rootOutlinerBone, groupArray)).toList());
        }
        return bones.toArray(new JsonObject[0]);
    }

    /**
     *
     * Gets an list of pairs with all the bones in all .bbmodel files and all the rootJsonObjects belonging to them.
     *
     * @return The List of pairs with all the bones and root files, pair.left is the bone, and pair.right is the rootJsonObject.
     */
    private static List<Pair<JsonObject, JsonObject>> getAllBonesWithRootJson(){
        //TODO make this use the groups array
        File[] allModels = getAllFiles();
        List<Pair<JsonObject, JsonObject>> bonesAndRootJson = new ArrayList<>();
        for (File modelFile : allModels) {
            JsonObject modelData;
            Gson gson = new Gson();

            //Get rootJsonObject
            try(FileReader reader = new FileReader(modelFile)){
                JsonElement root = gson.fromJson(reader, JsonElement.class);
                modelData = root.getAsJsonObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            // Get rootbone in outliner
            JsonArray outlinerArray = modelData.get("outliner").getAsJsonArray();
            JsonObject rootOutlinerBone = outlinerArray.get(0).getAsJsonObject();

            // Get group
            JsonArray groupArray = modelData.get("groups").getAsJsonArray();


            // Get root bone
            JsonObject rootBone = getBoneFromUUID(rootOutlinerBone.get("uuid").getAsString(), groupArray);

            bonesAndRootJson.add(Pair.of(rootBone, modelData));
            bonesAndRootJson.addAll(getChildBonesWithRootJson(rootOutlinerBone, modelData, groupArray));
        }
        return bonesAndRootJson;
    }

    /**
     *
     * Gets all the bones under the root bone in the bone hierarchy.
     *
     * @param outlinerBone The root bone
     * @param groupArray The JsonArray called 'groups' with all the bones
     * @return All the bones under the bone.
     */
    private static JsonObject[] getChildBones(JsonObject outlinerBone, JsonArray groupArray) {
        JsonArray childrenArray = outlinerBone.get("children").getAsJsonArray();

        List<JsonObject> bones = new ArrayList<>();
        for (JsonElement child : childrenArray) {
            if (child instanceof JsonObject childObject) {
                if (childObject.isJsonPrimitive()){continue;}
                bones.addAll(Arrays.asList(getChildBones(childObject, groupArray)));
                bones.add(getBoneFromUUID(childObject.get("uuid").getAsString(), groupArray));
            }
        }
        return bones.toArray(new JsonObject[0]);
    }

    /**
     *
     * Gets all the bones under the root bone in the bone hierarchy, and adds the rootJsonObject to all of them.
     *
     * @param bone The root bone
     * @param rootJson The rootJsonObject
     * @return All the bones under the bone and the rootJson in a list of pairs where pair.left is the bone, and pair.right is the rootJson.
     */
    private static List<Pair<JsonObject, JsonObject>> getChildBonesWithRootJson(JsonObject bone, JsonObject rootJson, JsonArray groupArray) {
        JsonArray childrenArray = bone.get("children").getAsJsonArray();

        List<Pair<JsonObject, JsonObject>> bonesAndRootJson = new ArrayList<>();

        for (JsonElement child : childrenArray) {
            if (child instanceof JsonObject childObject) {
                if (childObject.isJsonPrimitive()){continue;}
                bonesAndRootJson.add(Pair.of(getBoneFromUUID(childObject.get("uuid").getAsString(), groupArray), rootJson));
                bonesAndRootJson.addAll(getChildBonesWithRootJson(childObject, rootJson, groupArray));
            }
        }
        return bonesAndRootJson;
    }

    /**
     *
     * Get a bone in the 'groups' JsonArray from its UUID
     *
     * @param uuid The uuid to search for
     * @param groupArray The JsonArray 'groups' in the .bbmodel file
     * @return The bone or an empty JsonObject if none was found
     */
    public static JsonObject getBoneFromUUID(String uuid, JsonArray groupArray){

        JsonObject targetBone =  new JsonObject();
        // Get bone
        for (JsonElement bone : groupArray){
            if (!(bone instanceof JsonObject boneObject)){
                MultiItemDisplayEngine.plugin.getLogger().warning("'groups' jsonArray had a none JsonObject JsonElement (shouldn't be possible) bone info:"+bone.toString());
                continue;}
            if (boneObject.get("uuid").getAsString().equals(uuid)){
                targetBone = boneObject;
                break;
            }
        }

        return targetBone;
    }

    /**
     *
     * Get a bone in the 'outliner' JsonArray from its UUID
     *
     * @param uuid The uuid to search for
     * @param outlinerArray The JsonArray 'outliner' in the .bbmodel file
     * @return The bone or an empty JsonObject if none was found
     */
    public static JsonObject getOutlinerBoneFromUUID(String uuid, JsonArray outlinerArray){

        // Get rootBone
        JsonObject rootBone = outlinerArray.get(0).getAsJsonObject();
        if (rootBone.get("uuid").getAsString().equals(uuid)){return rootBone;}

        return getOutlinerBoneFromBoneAndUUID(uuid, rootBone);
    }

    /**
     *
     * Get a bone in the 'outliner' JsonArray from its UUID
     *
     * @param uuid The uuid to search for
     * @param outlinerBone The JsonObject with the bone to search in the .bbmodel file
     * @return The bone or an empty JsonObject if none was found
     */
    private static JsonObject getOutlinerBoneFromBoneAndUUID(String uuid, JsonObject outlinerBone){


        // Check if bone matches
        if (outlinerBone.get("uuid").getAsString().equals(uuid)){return outlinerBone;}

        // Loop through children
        for (JsonElement bone : outlinerBone.get("children").getAsJsonArray()){
            if (!(bone instanceof JsonObject boneObject)){continue;}

            return getOutlinerBoneFromBoneAndUUID(uuid, boneObject);
        }

        return new JsonObject();
    }
}

